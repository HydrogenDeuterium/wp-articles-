# X分钟速成 Y

## 其中Y=nrex

nrex 是 Non-regular expression 的缩写，是一种不同于正则表达式的匹配方式。

## 为什么，为什么不？

正则表达式一个较大的缺陷在于，难以阅读和理解。
举例来说，子表达式和断言的小括号让人望而生畏。
nrex 的发明就是为了解决这一问题。

nrex 通过重新设计元字符的意义太提高字符串匹配模式的可读性和可维护性。

## 元字符

和 regex 一样，nrex 的元字符包括 \^$?:.*()[]{}<>,使用元字符时应当使用反斜杠转义。值得一提，-:字符也是 nrex 的元字符。

其中：

- \ 用于转义。
- ^_ 用于匹配单词/行的边界
- ?* 用于通配。
- (^|) 用于选择匹配，类似regex的[]。
- [+?*] 用于标记匹配数量，这一点和regex的{}比较接近。
- (:)$ 用于标记子表达式并获取，类似regex的（）
- <-> 用于断言。

## 语法

### 通配符*？

为了减少出现大量的".*"，因此和路径匹配类似，nrex 使用 "*?" 作为通配，而不再需要在前面加入大量的“.”进行通配。

其中，*通配任意数量的字符，？通配单个数量的字符。

在 regex 中使用“?+*”等字符限定前一个元素的作用参见匹配数量一节。

### 定位点

这一功能与regex基本一致，区别在于.代替了$匹配结尾，其他不再赘述。

### 选择匹配

在不加修饰的情况下，{}仅作为打包其中多个元素为一个元素的作用，和数学概念上的集合类似。

{}匹配其中用|分隔得到的任何一组元素。

在（）的开头，可以添加以下修饰符来改变其作用：

- ^:反向匹配，和regex中[]开头的^等价。

### 限定匹配

在regex中，限定匹配包括?+*{}等多种后缀，在nrex中，这些后缀被[]所统一。

之所以选择[]，是因为在绝大部分语言中用方括号表示数组或其他可迭代对象的下标，因此用其限定数量是合理的。

在[]的结尾，可以添加这些修饰字符：

- ?表示非贪婪匹配，即次数尽可能少。如果不添加默认情况是贪婪的，即尽可能多的匹配

[]中支持以下种类的匹配：

- [n]恰好n次
- [n,]至少n次
- [n,m]m到n次之间

可以使用 ?+*作为语法糖：

- ?=0,1
- +=1,
- *=0,

### 子表达式

默认情况下，()仅仅用于将其中的元素作为一个整体。

可以用:来标记子表达式，标记的子表达式匹配的内容可以在之后通过\1的方式获取，并且在完成匹配后通过match.groups()之类的方式轻松获取。

默认情况下，结果是按照匹配到的顺序排列的，但你也可以在:前给结果命名。

命名的规则类似于 php 或 lua 中的array，实质是一个有着自动递增的整数key的映射表。使用$获取被命名的内容.

- {2:bar} $2
- {bar:bar} ->$bar

注意：如果:前的索引是纯数字的，那就会生成数字索引。非数

如果:前什么都没有，那么这个匹配结果的索引会从1开始自动递增。（不从零开始是因为0被分配给了整个nrex表达式）

### 断言

这个功能类似于regex中的(?<=>!)功能。在regex中其有许多名字，包括零宽预测断言，预测，回顾等等。其功能很简单，即在不影响主匹配的情况下，对于主匹配增加一些限制条件。

nrex使用<->来标记一个断言，要求该位置的之后必须匹配断言内容。其中-表示当前位置。

在-之后的匹配内容类似regex的“零宽正预测先行断言”，之前的匹配内容类似“零宽正回顾后发断言”

断言只会识别其中的第一个-，之后的-会视为匹配内容的一部分，因此-前断言中的-要进行转义。

在断言最开头添加^表示反向匹配，类似于regex的"负断言"，要求该位置的前后不能匹配断言内容。

### 注释

在断言中没有找到-的情况下，断言无效，这可以被用于进行注释。

### 平衡组

nrex不支持平衡组。

## 写在最后
我将在下一篇文章中详细描述几个具体样例中的 nrex 匹配，并且与对应的regex匹配进行对比。
